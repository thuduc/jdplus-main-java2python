/*
 * Copyright 2022 National Bank of Belgium
 *
 * Licensed under the EUPL, Version 1.2 or â€“ as soon they will be approved 
 * by the European Commission - subsequent versions of the EUPL (the "Licence");
 * You may not use this work except in compliance with the Licence.
 * You may obtain a copy of the Licence at:
 *
 * https://joinup.ec.europa.eu/software/page/eupl
 *
 * Unless required by applicable law or agreed to in writing, software 
 * distributed under the Licence is distributed on an "AS IS" basis,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the Licence for the specific language governing permissions and 
 * limitations under the Licence.
 */
package jdplus.toolkit.base.core.ssf.composite;

import jdplus.toolkit.base.core.data.DataBlock;
import jdplus.toolkit.base.core.data.DataWindow;
import jdplus.toolkit.base.core.math.matrices.FastMatrix;
import jdplus.toolkit.base.core.math.matrices.MatrixWindow;
import jdplus.toolkit.base.core.ssf.ISsfDynamics;
import jdplus.toolkit.base.core.ssf.SsfException;

/**
 * Dynamics generated by a juxtaposition of several dynamics. The underlying
 * state is the concatenation of the original states.
 * We suppose that the innovations of the different blocks are independent
 *
 * @author Jean Palate
 */
public class CompositeDynamics implements ISsfDynamics {

    private final ISsfDynamics[] dyn;
    private final int[] dim;

    /**
     * Concatenation of the different dynamics.
     * @param dim Dimensions of the different blocks 
     * @param dyn Dynamics of the different blocks
     *
     */
    public CompositeDynamics(int[] dim, ISsfDynamics... dyn) {
        if (dim.length != dyn.length)
            throw new SsfException(SsfException.MODEL);
        this.dim = dim;
        this.dyn = dyn;
    }

    public int getComponentsCount() {
        return dyn.length;
    }

    public ISsfDynamics getComponent(int pos) {
        return dyn[pos];
    }

    @Override
    public boolean isTimeInvariant() {
        for (int i = 0; i < dyn.length; ++i) {
            if (!dyn[i].isTimeInvariant()) {
                return false;
            }
        }
        return true;
    }

    @Override
    public boolean areInnovationsTimeInvariant() {
        for (int i = 0; i < dyn.length; ++i) {
            if (!dyn[i].areInnovationsTimeInvariant()) {
                return false;
            }
        }
        return true;
    }

    @Override
    public int getInnovationsDim() {
        int ni = 0;
        for (int i = 0; i < dyn.length; ++i) {
            ni += dyn[i].getInnovationsDim();
        }
        return ni;
    }

    @Override
    public void V(int pos, FastMatrix qm) {
        MatrixWindow cur = qm.topLeft(0, 0);
        for (int i = 0; i < dyn.length; ++i) {
            dyn[i].V(pos, cur.next(dim[i], dim[i]));
        }
    }

    @Override
    public boolean hasInnovations(int pos) {
        for (int i = 0; i < dyn.length; ++i) {
            if (dyn[i].hasInnovations(pos)) {
                return true;
            }
        }
        return false;
    }

    @Override
    public void S(int pos, FastMatrix sm) {
        MatrixWindow cur = sm.topLeft(0, 0);
        for (int i = 0; i < dyn.length; ++i) {
            int rcount = dim[i];
            int rdim = dyn[i].getInnovationsDim();
            FastMatrix next = cur.next(rcount, rdim);
            if (rdim > 0) {
                dyn[i].S(pos, next);
            }
        }
    }

    @Override
    public void addSU(int pos, DataBlock x, DataBlock u) {
        DataWindow xwnd = x.left(), uwnd = u.left();
        for (int i = 0; i < dyn.length; ++i) {
            int rcount = dim[i];
            int rdim = dyn[i].getInnovationsDim();
            DataBlock xcur = xwnd.next(rcount);
            if (rdim > 0) {
                dyn[i].addSU(pos, xcur, uwnd.next(rdim));
            }
        }
    }

    @Override
    public void XS(int pos, DataBlock x, DataBlock xs) {
        DataWindow xwnd = x.left(), ywnd = xs.left();
        for (int i = 0; i < dyn.length; ++i) {
            int rcount = dim[i];
            int rdim = dyn[i].getInnovationsDim();
            DataBlock xcur = xwnd.next(rcount);
            if (rdim > 0) {
                dyn[i].XS(pos, xcur, ywnd.next(rdim));
            }
        }
    }

    @Override
    public void T(int pos, FastMatrix tr) {
        MatrixWindow cur = tr.topLeft(0, 0);
        for (int i = 0; i < dyn.length; ++i) {
            dyn[i].T(pos, cur.next(dim[i], dim[i]));
        }
    }

    @Override
    public void TX(int pos, DataBlock x) {
        DataWindow cur = x.window(0, dim[0]);
        dyn[0].TX(pos, cur.get());
        for (int i = 1; i < dyn.length; ++i) {
            dyn[i].TX(pos, cur.next(dim[i]));
        }
    }

    @Override
    public void TM(int pos, FastMatrix x) {
        MatrixWindow cur = x.top(0);
        for (int i = 0; i < dyn.length; ++i) {
            dyn[i].TM(pos, cur.vnext(dim[i]));
        }
    }

    @Override
    public void XT(int pos, DataBlock x) {
        DataWindow cur = x.left();
        for (int i = 0; i < dyn.length; ++i) {
            dyn[i].XT(pos, cur.next(dim[i]));
        }
    }

    @Override
    public void TVT(int pos, FastMatrix v) {
        MatrixWindow D = v.topLeft(0, 0);
        for (int i = 0; i < dyn.length; ++i) {
            int ni = dim[i];
            FastMatrix nD = D.next(ni, ni);
            dyn[i].TVT(pos, nD);
            MatrixWindow C = MatrixWindow.of(nD), R = MatrixWindow.of(nD);
            for (int j = i + 1; j < dyn.length; ++j) {
                int nj = dim[j];
                FastMatrix nC = C.vnext(nj);
                FastMatrix nR = R.hnext(nj);
                dyn[j].TM(pos, nC);
                dyn[i].MTt(pos, nC);
                nR.copyTranspose(nC);
            }
        }
    }

    @Override
    public void addV(int pos, FastMatrix p
    ) {
        MatrixWindow cur = p.topLeft(0, 0);
        for (int i = 0; i < dyn.length; ++i) {
            dyn[i].addV(pos, cur.next(dim[i], dim[i]));
        }
    }
}
